#!/usr/bin/env bash

me=scrappingInstall
function commonHelp(){
  echo "Usage: $me  (--makeBin) (--envVariables) (--help)"
  echo "   Remember that if you want to change environment variables, this must be 'source'ed"
}
if [  $# -lt 1 ] ; then
   commonHelp
   exit 1
fi


function importInstallationGuide(){
echo "

Running githubscrapping on your laptop
    Download the git repo
    Find your api key from github
    source scripts/env/$me --setEmailAndNameFromGit --envVariables --apikey <myapikey>



Troubleshooting:
    When running $me remember that $me modifies environment variables. It should normally be executed by 'source'
    From the root of this project 'source scripts/env/$me (options)' is the usual command
"
   exit
}

function importInstallHelp(){
#!/usr/bin/env bash
    commonHelp
    echo "   --help                           # display this"
    echo "   --firstTime                      # partially sets up import (enough to run, but not enough to do serious things) and then displays 'getting going' instructions"
    echo "   --installationGuide              # displays instructions on how to get started"
    echo "   --apikey  key                    # sets your apikey"
    echo "   --makeBin                        # sets up the symbolic links and updates the path"
    echo "   --chmod                          #  makes sure the SCRIPT_DIR has 'chmod u+x' on all files"
    echo "   --setEmailAndNameFromGit         # sets the environment variables for email and username from git. This is run on your laptop so that import jobs on azure use your details"
    echo "   --envVariables                   # initialises the environment variablse and updates the path ASSUMPTION: executing in root folder"
    echo "   -c | --conf                      # defines the directory that the configuration is found in"

    exit
}

function optionallyChangeDirectoryToimport(){
   if [ "$import_git_dir" != "" ]; then
      pushd $import_git_dir
   else
      pushd .
   fi
}

function checkPwdHasScriptsDirectory(){
   if [ ! -d "scripts" ]; then
       echo "importInstall $1 must be run in a folder with a scripts subdirectory. pwd is `pwd`"
       exit 2
    fi
 }

function optionalMakeBin(){
   optionallyChangeDirectoryToimport > /dev/null
      if [ -d bin ] ; then
         popd > /dev/null
         return
      fi
   popd > /dev/null
   makeBin
}

function makeBin(){
    optionallyChangeDirectoryToimport > /dev/null
        echo "makeBin `pwd` (making symbolic links to scripts and adding that directory to the path)"
        checkPwdHasScriptsDirectory --makeBin
        rm -rf bin
        mkdir bin
        cd bin
        bindir=`pwd`
        find ../scripts -maxdepth 3 -type f ! -name "*.*" -exec ln -s {}  \;
        find ../scripts -maxdepth 3 -type f  -name "*.sh" -exec ln -s {}  \;
        chmod u+x ../scripts
        setPath $bindir
    popd > /dev/null
    }

function makeBinForTemp(){
    optionallyChangeDirectoryToimport > /dev/null
        echo "makeBinForTemps `pwd` (making symbolic links to scripts and adding that directory to the path)"
        checkPwdHasScriptsDirectory --makeBin
        rm -rf bin
        mkdir bin
        cd bin
        bindir=`pwd`
        find ../scripts/temp -maxdepth 2 -type f ! -name "*.*" -exec ln -s {}  \;
        find ../scripts/temp -maxdepth 2 -type f  -name "*.sh" -exec ln -s {}  \;
        setPath $bindir
    popd > /dev/null
    }

function envVariables(){
     optionallyChangeDirectoryToimport > /dev/null
        echo "setting envVariables and current directory is `pwd` (if not running using source, this will do nothing)"
        checkPwdHasScriptsDirectory --envVariables
        tempsh=`mktemp`
        export pwd=`pwd`
        export whoami=`whoami`
        cat $pwd/scripts/env/env.txt | awk '{ print "export " $1  "=" $2 "" }' > $tempsh
        source $tempsh
        rm $tempsh
        export import_LOG_INDENT='...'
        setPath `pwd`/bin
    popd > /dev/null
}

function setPath(){
   bindir=$1
   if [[ $PATH != *"$bindir"* ]]; then
       export PATH=$bindir:$PATH
   fi
}

function checkEnv(){
   var=$1
  if [ "${!1}" = "" ]; then
     echo "importInstall needs $1 set"
     exit 2
  fi
}

function withApiKey(){
  sed s^https://$ORGANISATION@^https://$ORGANISATION:${!apikey_name}@^g <<< $1
}

function checkApiKey(){
   if [ "$apikey_name" = "" ]; then
      echo "apikey_name not defined"
      exit 2
    fi
    if [ "${!apikey_name}" = "" ]; then
      echo "apikey_name [$apikey_name] references an environment variable that is empty"
      exit 2
    fi
 }


function setEmailAndNameFromGit(){
   export gitusername=`git config --get user.name`
   export gituseremail=`git config --get user.email`
}

ORIGINAL=( "$@" )
POSITIONAL=()
while [[ $# -gt 0 ]]
do
    key="$1"
    case $key in
       --help)              importInstallHelp; exit;;
       --installationGuide) displayInstallationGuide="true" ; shift;;
       --firstTime)         bin="true"; env="true";chmod="true"; first="true"; makeScripts="true"; shift;;
       --makeBin)           bin="true"; shift;;
       --envVariables)      env="true"; shift;;
       --chmod)             chmod="true"; shift;;
       --apikey)            apiname=`whoami`_apikey; export $apiname=$2; shift;shift;;
       --makeScripts)       makeScripts="true"; shift;;
       --setEmailAndNameFromGit) setEmailAndNameFromGit; shift;;
       *)                   POSITIONAL+=( "$1" ); shift;;
    esac
done

if [ ${#POSITIONAL[@]} -gt 0 ]; then
   echo "Did not understand parameters ${POSITIONAL}";
   exit 2;
fi

case "$bin" in
   "true")  makeBin;;
   "maybe") optionalMakeBin;;
   *) ;;
esac

if [ "$env" ]; then
   envVariables
fi

if [ "$chmod" != "" ]; then
   optionallyChangeDirectoryToimport > /dev/null
       checkPwdHasScriptsDirectory  --chmod
       echo "executing chmod -R u+x $SCRIPT_DIR"
       chmod -R u+x $SCRIPT_DIR
   popd > /dev/null
fi

if [ "$displayInstallationGuide" != "" ]; then
  importInstallationGuide
fi


if [ "$fromAzure" != "" ]; then
    echo "importgit $importgit"
    echo "import_git_dir $import_git_dir"
    echo "inputgit $inputgit"
    echo "input_git_dir $input_git_dir"
    echo "jobgit $jobgit"
    echo "job_git_dir $job_git_dir"
fi

